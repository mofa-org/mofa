<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MoFA Workflow Visualizer</title>
    <!-- Use basic CSS, standard font -->
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #header {
            background-color: #343a40;
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #workflow-selector {
            padding: 5px;
            font-size: 14px;
        }

        #d3-container {
            flex: 1;
            position: relative;
        }

        /* Node styles */
        .node rect {
            stroke: #333;
            stroke-width: 1.5px;
            rx: 5;
            ry: 5;
        }

        .node text {
            font-size: 12px;
            pointer-events: none;
        }

        .node .title {
            font-weight: bold;
            font-size: 14px;
        }

        /* Edge styles */
        .link {
            fill: none;
            stroke: #999;
            stroke-width: 2px;
        }

        .link.conditional {
            stroke-dasharray: 4, 4;
        }

        .link.error {
            stroke: #e74c3c;
            stroke-dasharray: 2, 2;
        }

        /* Node Colors by Type */
        .color-Start {
            fill: #2ecc71;
        }

        .color-End {
            fill: #e74c3c;
        }

        .color-Task {
            fill: #3498db;
        }

        .color-Agent {
            fill: #9b59b6;
        }

        .color-Condition {
            fill: #f1c40f;
        }

        .color-Parallel {
            fill: #1abc9c;
        }

        .color-Join {
            fill: #16a085;
        }

        .color-Default {
            fill: #ecf0f1;
        }

        /* Execution Status Overrides */
        .status-running rect {
            stroke: #f39c12;
            stroke-width: 3px;
            filter: drop-shadow(0 0 5px #f39c12);
        }

        .status-completed rect {
            stroke: #27ae60;
            stroke-width: 3px;
        }

        .status-failed rect {
            stroke: #c0392b;
            stroke-width: 3px;
        }

        .tooltip {
            position: absolute;
            text-align: left;
            padding: 8px;
            font-size: 12px;
            background: white;
            border: 1px solid #ddd;
            box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            z-index: 10;
            max-width: 300px;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            border: 1px solid #ddd;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 8px;
            border: 1px solid #333;
            border-radius: 3px;
        }

        /* Loading overlay */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            z-index: 20;
            display: none;
        }

        /* Time Travel Controls */
        #playback-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            left: 240px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid #ddd;
            display: flex;
            align-items: center;
            gap: 15px;
            display: none;
            z-index: 10;
        }

        #playback-controls button {
            padding: 8px 15px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background: #3498db;
            color: white;
            font-weight: bold;
        }

        #playback-controls button:hover {
            background: #2980b9;
        }

        #playback-controls button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        #timeline-slider {
            flex: 1;
            cursor: pointer;
        }

        #step-counter {
            font-family: monospace;
            font-size: 14px;
            min-width: 60px;
            text-align: center;
        }

        /* Sidebar for state inspection */
        #sidebar {
            position: absolute;
            top: 60px;
            right: 0;
            bottom: 0;
            width: 350px;
            background: white;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            border-left: 1px solid #ddd;
            padding: 20px;
            overflow-y: auto;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 15;
        }

        #sidebar.open {
            transform: translateX(0);
        }

        #sidebar h3 {
            margin-top: 0;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .state-block {
            background: #f8f9fa;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .state-block pre {
            margin: 0;
            font-size: 12px;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #333;
        }

        #close-sidebar {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #7f8c8d;
        }
    </style>
    <!-- Exclude heavy dependencies and just use D3 and Dagre for layout -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js"></script>
</head>

<body>
    <div id="canvas-container">
        <div id="header">
            <h2>üé® MoFA Workflow Visualizer</h2>
            <div>
                <label for="workflow-selector">Select Workflow: </label>
                <select id="workflow-selector">
                    <option value="">Loading workflows...</option>
                </select>
            </div>
        </div>
        <div id="d3-container">
            <svg id="svg" width="100%" height="100%"></svg>
            <div id="tooltip" class="tooltip"></div>
            <div id="loading">Loading graph data...</div>
            <div class="legend">
                <h4>Node Types</h4>
                <div class="legend-item">
                    <div class="legend-color color-Start"></div> Start
                </div>
                <div class="legend-item">
                    <div class="legend-color color-Task"></div> Task
                </div>
                <div class="legend-item">
                    <div class="legend-color color-Agent"></div> Agent
                </div>
                <div class="legend-item">
                    <div class="legend-color color-Condition"></div> Condition
                </div>
                <div class="legend-item">
                    <div class="legend-color color-Parallel"></div> Parallel/Join
                </div>
                <div class="legend-item">
                    <div class="legend-color color-End"></div> End
                </div>
                <hr>
                <div class="legend-item"><em>* Click node during replay to inspect state</em></div>
            </div>

            <!-- Playback Controls -->
            <div id="playback-controls">
                <button id="btn-prev">‚èÆ Prev</button>
                <button id="btn-play">‚ñ∂ Play</button>
                <button id="btn-next">Next ‚è≠</button>
                <input type="range" id="timeline-slider" min="0" max="0" value="0" disabled>
                <div id="step-counter">0 / 0</div>
            </div>

            <!-- State Inspection Sidebar -->
            <div id="sidebar">
                <button id="close-sidebar">&times;</button>
                <h3 id="sidebar-node-name">Node Inspector</h3>
                <div style="font-size: 13px; color: #7f8c8d; margin-bottom: 15px;" id="sidebar-node-info">Select a node
                    to view state.</div>

                <h4>Input Payload</h4>
                <div class="state-block">
                    <pre id="sidebar-input">Hover/Click a node to view state at current step.</pre>
                </div>

                <h4>Output Payload</h4>
                <div class="state-block">
                    <pre id="sidebar-output">Waiting...</pre>
                </div>

                <h4>Execution Details</h4>
                <div class="state-block" style="font-size: 13px;">
                    <div><strong>Status:</strong> <span id="sidebar-status">-</span></div>
                    <div><strong>Duration:</strong> <span id="sidebar-duration">-</span></div>
                    <div id="sidebar-error-container" style="display: none; color: #e74c3c; margin-top: 10px;">
                        <strong>Error:</strong>
                        <pre id="sidebar-error"></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = '/api'; // Use relative path if hosted together
        let currentSimulatorInterval = null;

        // Configuration
        const NODE_WIDTH = 150;
        const NODE_HEIGHT = 60;

        // Initialize UI
        async function fetchWorkflows() {
            try {
                const res = await fetch(`${API_BASE}/workflows`);
                const json = await res.json();
                if (json.success && json.data) {
                    const selector = document.getElementById('workflow-selector');
                    selector.innerHTML = '<option value="">-- Select a Workflow --</option>';
                    json.data.forEach(wf => {
                        const opt = document.createElement('option');
                        opt.value = wf.workflow_id;
                        opt.textContent = `${wf.name} (${wf.workflow_id})`;
                        selector.appendChild(opt);
                    });

                    // Add a default Mock graph if API fails to provide one
                    const mockOpt = document.createElement('option');
                    mockOpt.value = "mock_demo";
                    mockOpt.textContent = "Demo Mock Workflow";
                    selector.appendChild(mockOpt);
                }
            } catch (err) {
                console.error("Failed to fetch workflows", err);
            }
        }

        async function loadGraph(workflowId) {
            document.getElementById('loading').style.display = 'flex';
            resetPlayback();

            // Allow a demo mock
            if (workflowId === "mock_demo") {
                renderGraph(getMockGraph());
                loadRecordingData(getMockRecording());
                document.getElementById('loading').style.display = 'none';
                return;
            }

            try {
                const res = await fetch(`${API_BASE}/workflows/${workflowId}/graph`);
                const json = await res.json();
                if (json.success && json.data) {
                    renderGraph(json.data);

                    // Try fetching recording data now
                    const recRes = await fetch(`${API_BASE}/workflows/${workflowId}/recording`);
                    const recJson = await recRes.json();
                    if (recJson.success && recJson.data) {
                        loadRecordingData(recJson.data);
                    }
                } else {
                    alert("Graph data not found. Ensure WorkflowMetrics stores `graph_json`.");
                    renderGraph({ nodes: [], edges: [] });
                }
            } catch (err) {
                console.error("Failed to load graph", err);
                alert("Error loading graph. See console.");
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        function renderGraph(graphData) {
            // Setup SVG
            const svg = d3.select("#svg");
            svg.selectAll("*").remove(); // Clear previous

            const width = document.getElementById("d3-container").clientWidth;
            const height = document.getElementById("d3-container").clientHeight;

            // Setup Zoom
            const zoom = d3.zoom().on("zoom", (event) => {
                g.attr("transform", event.transform);
            });
            svg.call(zoom);

            // Add arrow markers
            const defs = svg.append("defs");
            defs.append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", NODE_WIDTH / 2 + 10)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#999");

            const g = svg.append("g");

            // Use Dagre for layout
            const gDagre = new dagre.graphlib.Graph();
            gDagre.setGraph({ rankdir: 'TB', marginx: 20, marginy: 20, ranksep: 60, nodesep: 60 });
            gDagre.setDefaultEdgeLabel(() => ({}));

            // Add nodes to dagre
            graphData.nodes.forEach(node => {
                gDagre.setNode(node.id, {
                    label: node.name,
                    width: NODE_WIDTH,
                    height: NODE_HEIGHT,
                    data: node
                });
            });

            // Add edges to dagre
            graphData.edges.forEach(edge => {
                gDagre.setEdge(edge.from, edge.to, { data: edge });
            });

            // Calculate layout
            dagre.layout(gDagre);

            // Draw Edges
            const edgeSelection = g.selectAll(".link")
                .data(gDagre.edges().map(e => gDagre.edge(e)))
                .enter().append("path")
                .attr("class", d => {
                    let cls = "link";
                    if (d.data?.edge_type) {
                        if (typeof d.data.edge_type === 'object' && d.data.edge_type.Conditional) cls += " conditional";
                        if (d.data.edge_type === 'Error') cls += " error";
                    }
                    return cls;
                })
                .attr("marker-end", "url(#arrow)")
                .attr("d", d => {
                    // Curved paths
                    const generator = d3.line().x(p => p.x).y(p => p.y).curve(d3.curveBasis);
                    return generator(d.points);
                });

            // Draw Edge Labels
            g.selectAll(".edge-label")
                .data(gDagre.edges().map(e => gDagre.edge(e)))
                .enter().append("text")
                .attr("class", "edge-label")
                .style("font-size", "10px")
                .style("fill", "#555")
                .attr("x", d => {
                    if (d.points.length > 1) return d.points[Math.floor(d.points.length / 2)].x;
                    return 0;
                })
                .attr("y", d => {
                    if (d.points.length > 1) return d.points[Math.floor(d.points.length / 2)].y - 5;
                    return 0;
                })
                .text(d => d.data?.label || "");

            // Draw Nodes
            const nodeSelection = g.selectAll(".node")
                .data(gDagre.nodes().map(v => gDagre.node(v)))
                .enter().append("g")
                .attr("class", "node")
                .attr("id", d => `node-${d.data.id}`)
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .on("mouseover", showTooltip)
                .on("mouseout", hideTooltip);

            nodeSelection.append("rect")
                .attr("class", d => `node color-${d.data.node_type || 'Default'}`)
                .attr("id", d => `node-rect-${d.data.id}`)
                .attr("x", -NODE_WIDTH / 2)
                .attr("y", -NODE_HEIGHT / 2)
                .attr("width", NODE_WIDTH)
                .attr("height", NODE_HEIGHT);

            nodeSelection.append("text")
                .attr("class", "title")
                .attr("text-anchor", "middle")
                .attr("y", -5)
                .style("fill", "#fff")
                .style("text-shadow", "1px 1px 2px #000") // readibility
                .text(d => d.data.name.length > 20 ? d.data.name.substring(0, 17) + '...' : d.data.name);

            nodeSelection.append("text")
                .attr("text-anchor", "middle")
                .attr("y", 15)
                .style("fill", "#eee")
                .text(d => d.data.node_type);

            // Center graph
            if (gDagre.nodes().length > 0) {
                const graphWidth = gDagre.graph().width;
                const graphHeight = gDagre.graph().height;
                const scale = Math.min(1, Math.min(width / graphWidth, height / graphHeight) * 0.9);
                const tx = (width - graphWidth * scale) / 2;
                const ty = (height - graphHeight * scale) / 2;
                svg.call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
            }
        }

        function showTooltip(event, d) {
            // Also update sidebar if available
            updateSidebarForNode(d.data.id, d.data.name);

            const tooltip = d3.select("#tooltip");
            tooltip.transition().duration(200).style("opacity", .9);

            let html = `<strong>${d.data.name}</strong><br/>
                        ID: ${d.data.id}<br/>
                        Type: ${d.data.node_type}<br/>`;
            if (d.data.description) {
                html += `<hr/><em>${d.data.description}</em>`;
            }

            // Execution simulation placeholder
            const currentStatus = d3.select(`#node-${d.data.id}`).attr("data-status");
            if (currentStatus) {
                html += `<hr/><strong>Status:</strong> ${currentStatus}`;
            }

            tooltip.html(html)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
        }

        function hideTooltip() {
            d3.select("#tooltip").transition().duration(500).style("opacity", 0);
        }

        // --- Replay Logic ---
        let recordingData = null;
        let currentStepIndex = -1;
        let playInterval = null;

        const slider = document.getElementById('timeline-slider');
        const playBtn = document.getElementById('btn-play');
        const prevBtn = document.getElementById('btn-prev');
        const nextBtn = document.getElementById('btn-next');
        const stepCounter = document.getElementById('step-counter');
        const controlsDiv = document.getElementById('playback-controls');

        function resetPlayback() {
            recordingData = null;
            currentStepIndex = -1;
            stopAutoPlay();
            controlsDiv.style.display = 'none';
            slider.value = 0;
            slider.max = 0;
            stepCounter.textContent = "0 / 0";
            document.getElementById('sidebar').classList.remove('open');
        }

        function loadRecordingData(data) {
            if (!data || !data.steps || data.steps.length === 0) return;
            recordingData = data;

            controlsDiv.style.display = 'flex';
            slider.max = data.steps.length - 1;
            slider.value = 0;
            slider.disabled = false;

            setStepIndices();
            applyStepState(0);
        }

        function setStepIndices() {
            const steps = recordingData.steps;
            for (let i = 0; i < steps.length; i++) {
                steps[i].globalIndex = i; // Map for quick lookup
            }
        }

        function applyStepState(stepIndex) {
            if (!recordingData) return;
            currentStepIndex = stepIndex;
            slider.value = stepIndex;
            stepCounter.textContent = `${stepIndex + 1} / ${recordingData.steps.length}`;

            // Clear all node statuses
            d3.selectAll('.node').attr("data-status", null)
                .classed("status-running status-completed status-failed", false);

            const steps = recordingData.steps;

            // Apply completed states for all prior nodes
            const completedNodes = new Set();
            for (let i = 0; i < stepIndex; i++) {
                const s = steps[i];
                if (s.status === "Success" || s.status === "Skipped") {
                    completedNodes.add(s.node_id);
                }
            }

            completedNodes.forEach(nodeId => {
                d3.select(`#node-${nodeId}`)
                    .attr("data-status", "completed")
                    .classed("status-completed", true);
            });

            // Highlight current step
            const currentStepData = steps[stepIndex];
            const nodeSel = d3.select(`#node-${currentStepData.node_id}`);

            let statusCls = "status-completed";
            if (currentStepData.status === "Running") statusCls = "status-running";
            if (currentStepData.status === "Failed") statusCls = "status-failed";

            nodeSel.attr("data-status", currentStepData.status.toLowerCase())
                .classed(statusCls, true);

            // Update sidebar if open
            updateSidebarForNode(currentStepData.node_id, null, currentStepData);
        }

        function updateSidebarForNode(nodeId, nodeName, forceStepData = null) {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.add('open');

            if (nodeName) {
                document.getElementById('sidebar-node-name').textContent = nodeName;
                document.getElementById('sidebar-node-info').textContent = `Node ID: ${nodeId}`;
            }

            // Find the most relevant step for this node up to current time
            let relevantStep = forceStepData;
            if (!relevantStep && recordingData && currentStepIndex >= 0) {
                for (let i = currentStepIndex; i >= 0; i--) {
                    if (recordingData.steps[i].node_id === nodeId) {
                        relevantStep = recordingData.steps[i];
                        break;
                    }
                }
            }

            const errBox = document.getElementById('sidebar-error-container');

            if (relevantStep) {
                document.getElementById('sidebar-input').textContent = relevantStep.input ? JSON.stringify(relevantStep.input, null, 2) : "None / Omitted";
                document.getElementById('sidebar-output').textContent = relevantStep.output ? JSON.stringify(relevantStep.output, null, 2) : "None / Omitted";
                document.getElementById('sidebar-status').textContent = relevantStep.status;

                let durMs = relevantStep.duration ? (relevantStep.duration.secs * 1000 + relevantStep.duration.nanos / 1e6) : 0;
                document.getElementById('sidebar-duration').textContent = `${durMs.toFixed(2)} ms`;

                if (relevantStep.error) {
                    errBox.style.display = 'block';
                    document.getElementById('sidebar-error').textContent = relevantStep.error;
                } else {
                    errBox.style.display = 'none';
                }
            } else {
                document.getElementById('sidebar-input').textContent = "Not executed yet.";
                document.getElementById('sidebar-output').textContent = "Not executed yet.";
                document.getElementById('sidebar-status').textContent = "Pending";
                document.getElementById('sidebar-duration').textContent = "-";
                errBox.style.display = 'none';
            }
        }

        function togglePlay() {
            if (playInterval) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }

        function startAutoPlay() {
            if (!recordingData) return;
            if (currentStepIndex >= recordingData.steps.length - 1) {
                applyStepState(0); // loop around
            }
            playBtn.textContent = '‚è∏ Pause';
            playInterval = setInterval(() => {
                if (currentStepIndex < recordingData.steps.length - 1) {
                    applyStepState(currentStepIndex + 1);
                } else {
                    stopAutoPlay();
                }
            }, 600); // 600ms per step
        }

        function stopAutoPlay() {
            clearInterval(playInterval);
            playInterval = null;
            playBtn.textContent = '‚ñ∂ Play';
        }

        // Setup DOM Events
        slider.addEventListener('input', (e) => {
            stopAutoPlay();
            applyStepState(parseInt(e.target.value));
        });
        playBtn.addEventListener('click', togglePlay);
        prevBtn.addEventListener('click', () => {
            stopAutoPlay();
            if (currentStepIndex > 0) applyStepState(currentStepIndex - 1);
        });
        nextBtn.addEventListener('click', () => {
            stopAutoPlay();
            if (recordingData && currentStepIndex < recordingData.steps.length - 1) applyStepState(currentStepIndex + 1);
        });
        document.getElementById('close-sidebar').addEventListener('click', () => {
            document.getElementById('sidebar').classList.remove('open');
        });

        // --- Demo Mock Data --- //
        function getMockGraph() {
            return {
                id: "demo1",
                name: "Demo Workflow",
                nodes: [
                    { id: "n1", name: "Start Request", node_type: "Start", description: "Entry point" },
                    { id: "n2", name: "Validate Data", node_type: "Task", description: "Format checking" },
                    { id: "n3", name: "Is Valid?", node_type: "Condition", description: "Check if valid" },
                    { id: "n4", name: "Log Error", node_type: "Task", description: "Log failure" },
                    { id: "n5", name: "Analyze (LLM)", node_type: "Agent", description: "LLM Agent call" },
                    { id: "n6", name: "Translate (LLM)", node_type: "Agent", description: "LLM Translator" },
                    { id: "n7", name: "Format Report", node_type: "Task", description: "JSON format" },
                    { id: "n8", name: "End", node_type: "End", description: "Done" }
                ],
                edges: [
                    { from: "n1", to: "n2", edge_type: "Normal" },
                    { from: "n2", to: "n3", edge_type: "Normal" },
                    { from: "n3", to: "n4", edge_type: { Conditional: "false" }, label: "false" },
                    { from: "n3", to: "n5", edge_type: { Conditional: "true" }, label: "true" },
                    { from: "n3", to: "n6", edge_type: { Conditional: "true" }, label: "true" },
                    { from: "n5", to: "n7", edge_type: "Normal" },
                    { from: "n6", to: "n7", edge_type: "Normal" },
                    { from: "n7", to: "n8", edge_type: "Normal" },
                    { from: "n4", to: "n8", edge_type: "Normal" }
                ]
            };
        }

        function getMockRecording() {
            return {
                execution_id: "idx-demo",
                workflow_id: "demo1",
                total_duration: { secs: 1, nanos: 0 },
                steps: [
                    { node_id: "n1", status: "Success", duration: { secs: 0, nanos: 1000000 }, input: { data: "start" }, output: { ready: true } },
                    { node_id: "n2", status: "Success", duration: { secs: 0, nanos: 5000000 }, input: { ready: true }, output: { is_valid: true } },
                    { node_id: "n3", status: "Success", duration: { secs: 0, nanos: 2000000 }, input: { is_valid: true }, output: "true" },
                    { node_id: "n5", status: "Running", duration: { secs: 0, nanos: 0 }, input: "true", output: null },
                    { node_id: "n6", status: "Running", duration: { secs: 0, nanos: 0 }, input: "true", output: null },
                    { node_id: "n5", status: "Success", duration: { secs: 0, nanos: 600000000 }, input: "true", output: { analysis: "done" } },
                    { node_id: "n6", status: "Success", duration: { secs: 0, nanos: 400000000 }, input: "true", output: { translate: "fini" } },
                    { node_id: "n7", status: "Success", duration: { secs: 0, nanos: 50000000 }, input: { n5: { analysis: "done" }, n6: { translate: "fini" } }, output: { final: true } },
                    { node_id: "n8", status: "Success", duration: { secs: 0, nanos: 1000000 }, input: { final: true }, output: null },
                ]
            };
        }

        // Connect events
        document.getElementById('workflow-selector').addEventListener('change', (e) => {
            if (e.target.value) {
                loadGraph(e.target.value);
            } else {
                resetPlayback();
                d3.select("#svg").selectAll("*").remove();
            }
        });

        fetchWorkflows();
    </script>
</body>

</html>